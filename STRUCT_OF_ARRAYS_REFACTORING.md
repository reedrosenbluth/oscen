# Struct-of-Arrays I/O Refactoring

This document describes the struct-of-arrays (SoA) I/O system refactoring in Oscen, inspired by CMajor's design pattern.

## Overview

Oscen now uses a CMajor-style struct-of-arrays pattern for handling node I/O. Each node with stream or event endpoints automatically gets a generated IO struct containing named fields for each endpoint. This provides:

- **Zero overhead**: Direct struct field access with no indirection
- **Type safety**: Each I/O field has a concrete type known at compile time
- **Named access**: I/O has meaningful names, not just indices
- **Multiple outputs**: Multiple outputs are just multiple fields in a struct
- **Clean separation**: Stream/event I/O is separate from persistent state

## How It Works

### 1. Node Definition

Nodes are defined using the `#[derive(Node)]` macro with input/output attributes:

```rust
#[derive(Debug, Node)]
pub struct Gain {
    #[input(stream)]   // Stream input -> goes in IO struct
    input: f32,

    #[input(value)]    // Value input -> stays in graph state
    gain: f32,

    #[output(stream)]  // Stream output -> goes in IO struct
    output: f32,
}
```

### 2. Generated IO Struct

The macro automatically generates an IO struct containing all stream and event endpoints:

```rust
// Generated by #[derive(Node)] macro
pub struct GainIO {
    pub input: f32,   // Stream input
    pub output: f32,  // Stream output
}
```

**Rules for what goes in the IO struct:**
- `#[input(stream)]` → field in IO struct
- `#[output(stream)]` → field in IO struct
- `#[input(event)]` → field in IO struct as `&[EventInstance]`
- `#[output(event)]` → field in IO struct as `Vec<EventInstance>`
- `#[input(value)]` → NOT in IO struct (accessed via graph/context)
- `#[output(value)]` → NOT in IO struct (stays in node state)

### 3. Processing Pattern

Nodes use the IO struct internally while keeping the trait object-safe:

```rust
impl SignalProcessor for Gain {
    fn process<'a>(&mut self, sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        // 1. Create IO struct (zero overhead - stack allocated)
        let mut io = GainIO {
            input: self.get_input(context),   // Populate from graph
            output: 0.0,
        };

        // 2. Get value inputs from graph state
        let gain = self.get_gain(context);

        // 3. Process using struct fields - this is the key innovation!
        io.output = io.input * gain;

        // 4. Return primary output (for trait object compatibility)
        io.output
    }
}
```

## Key Design Decisions

### Why Keep ProcessingContext?

We still use `ProcessingContext` to access value inputs because:
1. Value endpoints are stored in the graph's SlotMap, not per-node
2. They can be updated by the host or by connections
3. This matches CMajor's design where value endpoints live in the State

### Why Keep the Old Trait Signature?

We kept `fn process(...) -> f32` instead of `fn process(&mut Self::IO)` because:
1. **Trait object safety**: Rust's `Box<dyn SignalProcessor>` requires object-safe traits
2. **Associated types break object safety**: Adding `type IO` would prevent `Box<dyn>`
3. **Dynamic graphs**: Oscen supports runtime graph construction, unlike CMajor's compile-time generation
4. **Backward compatibility**: Existing nodes still work

The IO struct is created internally and remains a zero-overhead abstraction.

### Multiple Outputs

While we currently return a single primary output for trait compatibility, nodes can have multiple outputs by adding more fields to the IO struct:

```rust
#[derive(Debug, Node)]
pub struct MultiOutputNode {
    #[input(stream)]
    input: f32,

    #[output(stream)]
    output_left: f32,   // First output

    #[output(stream)]
    output_right: f32,  // Second output
}

// Generated:
pub struct MultiOutputNodeIO {
    pub input: f32,
    pub output_left: f32,
    pub output_right: f32,
}

impl SignalProcessor for MultiOutputNode {
    fn process<'a>(&mut self, sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        let mut io = MultiOutputNodeIO {
            input: self.get_input(context),
            output_left: 0.0,
            output_right: 0.0,
        };

        // Process and write to multiple outputs
        io.output_left = io.input * 0.7;   // Left channel
        io.output_right = io.input * 0.3;  // Right channel

        // Return primary output (first stream output)
        io.output_left
    }
}
```

Future work could extend the graph execution to copy from all IO struct output fields to their connected inputs.

## Benefits

### 1. Zero Overhead
- IO struct is stack-allocated
- Direct field access with no indirection
- Compiler can optimize struct field access aggressively
- No virtual calls for I/O

### 2. Multiple Outputs are Natural
Instead of:
```rust
// Old pattern - only one output
return output;
```

We have:
```rust
// New pattern - multiple outputs as struct fields
io.output1 = ...;
io.output2 = ...;
io.output3 = ...;
```

### 3. Clear Code Intent
```rust
// Clear what's an input and what's an output
io.output = process(io.input);
```

Instead of:
```rust
// Less clear - indexed access
self.output = process(context.stream(0));
```

### 4. Type Safety
Each field has a concrete type. The compiler catches mismatches:
```rust
io.frequency = 440.0;  // OK
io.frequency = "high"; // Compile error
```

### 5. Self-Documenting
Field names document their purpose:
```rust
io.cutoff_frequency = ...;
io.resonance = ...;
io.filtered_output = ...;
```

## Examples

### Simple Node: AudioInput
```rust
#[derive(Debug, Node)]
pub struct AudioInput {
    #[input]          // Value input
    input_value: f32,

    #[output(stream)] // Stream output
    output: f32,
}

// Generated: AudioInputIO { output: f32 }
```

### Filter: IirLowpass
```rust
#[derive(Debug, Node)]
pub struct IirLowpass {
    #[input(stream)]  // Stream input
    input: f32,
    #[input]          // Value inputs
    cutoff: f32,
    #[input]
    q: f32,

    #[output(stream)] // Stream output
    output: f32,

    // Internal state (not endpoints)
    b0: f32, b1: f32, ...
}

// Generated: IirLowpassIO { input: f32, output: f32 }
```

### Oscillator with Multiple Stream Inputs
```rust
#[derive(Debug, Node)]
pub struct PolyBlepOscillator {
    #[input(stream)]  // Stream input 1
    phase_mod: f32,
    #[input(stream)]  // Stream input 2
    frequency_mod: f32,

    #[input(value)]   // Value inputs
    frequency: f32,
    #[input(value)]
    amplitude: f32,

    #[output(stream)] // Stream output
    output: f32,
}

// Generated: PolyBlepOscillatorIO {
//     phase_mod: f32,
//     frequency_mod: f32,
//     output: f32
// }
```

## Comparison with CMajor

### Similarities
- Each node has a State (persistent) and IO (per-sample) separation
- Stream I/O goes through struct fields
- Multiple outputs are natural
- Zero overhead struct-based access

### Differences
- **CMajor**: Compile-time code generation, knows all types statically
- **Oscen**: Runtime graph construction, uses trait objects
- **CMajor**: Graph directly copies between struct fields
- **Oscen**: IO struct is internal, graph still uses endpoint storage
- **CMajor**: Process signature is `fn process(state: &mut State, io: &mut IO)`
- **Oscen**: Process signature is `fn process(...) -> f32` (object-safe)

## Future Work

1. **Graph execution optimization**: Modify graph execution to directly copy between IO struct fields for connected nodes
2. **Multiple output routing**: Extend graph to route all IO struct outputs to their connections
3. **Event I/O**: Add full support for event inputs/outputs in IO structs
4. **Compile-time graphs**: Add a macro for compile-time graph generation that can fully leverage the IO struct pattern
5. **SIMD optimization**: IO struct layout could be optimized for SIMD operations

## Migration Guide

To update an existing node to use the struct-of-arrays pattern:

1. **Keep the field definitions**: The macro needs them to generate endpoints
2. **Create the IO struct in process()**: Populate it from `get_*` methods
3. **Use struct fields**: Read inputs from `io.field_name`, write outputs to `io.field_name`
4. **Return primary output**: Return the first/primary output value

Example migration:

```rust
// Before:
impl SignalProcessor for MyNode {
    fn process<'a>(&mut self, sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        let input = self.get_input(context);
        self.output = process_audio(input);
        self.output
    }
}

// After:
impl SignalProcessor for MyNode {
    fn process<'a>(&mut self, sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        // Create IO struct
        let mut io = MyNodeIO {
            input: self.get_input(context),
            output: 0.0,
        };

        // Process using struct fields
        io.output = process_audio(io.input);

        // Return primary output
        io.output
    }
}
```

## Nodes Updated

The following nodes have been updated to use the struct-of-arrays pattern:

- ✅ `Gain` - Simple gain node with stream I/O
- ✅ `AudioInput` - Audio input with value input and stream output
- ✅ `IirLowpass` - IIR filter with stream I/O and value parameters
- ✅ `Oscillator` - Basic oscillator with stream modulation
- ✅ `PolyBlepOscillator` - Anti-aliased oscillator with multiple stream inputs

## Conclusion

This refactoring brings Oscen closer to CMajor's elegant struct-of-arrays design while respecting Rust's type system constraints and maintaining backward compatibility. The result is clearer code, better performance potential, and a foundation for future optimizations.
