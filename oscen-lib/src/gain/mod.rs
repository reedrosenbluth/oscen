use crate::graph::{
    InputEndpoint, NodeKey, ProcessingContext, ProcessingNode, SignalProcessor, ValueKey,
};
use crate::Node;

/// Gain node using struct-of-arrays IO pattern.
///
/// The #[derive(Node)] macro generates:
/// - GainIO struct: holds stream I/O (input, output fields)
/// - GainEndpoints: typed endpoint handles
///
/// State (this struct): holds persistent data and value inputs
/// IO (generated GainIO): holds per-sample stream data
#[derive(Debug, Node)]
pub struct Gain {
    #[input(stream)]
    input: f32,

    #[input(value)]
    gain: f32,

    #[output(stream)]
    output: f32,
}

impl Gain {
    pub fn new(initial_gain: f32) -> Self {
        Self {
            input: 0.0,      // Placeholder for endpoint descriptor
            gain: initial_gain,  // Initial value for gain parameter
            output: 0.0,     // Placeholder for endpoint descriptor
        }
    }
}

impl Default for Gain {
    fn default() -> Self {
        Self::new(1.0)
    }
}

impl SignalProcessor for Gain {
    /// Process using struct-of-arrays I/O pattern (internally).
    ///
    /// The IO struct (GainIO) is created internally, populated from context,
    /// processed using struct fields, and the primary output is returned.
    ///
    /// This demonstrates the CMajor-style struct-of-arrays pattern while
    /// keeping the trait object-safe for dynamic graph construction.
    fn process<'a>(&mut self, _sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        // Create IO struct - generated by #[derive(Node)] macro
        // For Gain: struct GainIO { input: f32, output: f32 }
        let mut io = GainIO {
            input: self.get_input(context),   // Populate input from graph
            output: 0.0,
        };

        // Read gain value from graph (value input, not in IO struct)
        let gain = self.get_gain(context);

        // Process using struct fields - this is the key innovation!
        // Multiple outputs would just be more fields in the IO struct.
        // Zero overhead: direct field access, no indirection.
        io.output = io.input * gain;

        // Return primary output (for trait object compatibility)
        io.output
    }
}
