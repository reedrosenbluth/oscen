use super::traits::{ProcessingContext, SignalProcessor};
use super::{InputEndpoint, NodeKey, ProcessingNode, ValueKey};
use crate::Node;

/// AudioInput node using struct-of-arrays IO pattern.
///
/// Generates AudioInputIO with stream output field.
#[derive(Debug, Node)]
pub struct AudioInput {
    #[input]
    input_value: f32,  // Value input (stays in graph state)

    #[output(stream)]
    output: f32,  // Stream output (goes in AudioInputIO)
}

impl AudioInput {
    pub fn new() -> Self {
        Self {
            input_value: 0.0,
            output: 0.0,
        }
    }
}

impl Default for AudioInput {
    fn default() -> Self {
        Self::new()
    }
}

impl SignalProcessor for AudioInput {
    /// Process using struct-of-arrays I/O pattern (internally).
    ///
    /// AudioInputIO contains only the output field since there are no stream inputs.
    fn process<'a>(&mut self, _sample_rate: f32, context: &mut ProcessingContext<'a>) -> f32 {
        // Create IO struct (generated by macro)
        // AudioInputIO { output: f32 }
        let mut io = AudioInputIO {
            output: 0.0,
        };

        // Get value input from graph
        let input_val = self.get_input_value(context);

        // Write to IO struct output field
        io.output = input_val;

        // Return primary output
        io.output
    }
}
