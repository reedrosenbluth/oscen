
global MathConstants {
    out property <float> natural_log_base: 2.718281828459045;
}

global KnobPalette {
    in-out property <brush> dial_bg: #A9A9A9;
    in-out property <brush> border: #BABABA;
    in-out property <brush> marker: #777777;
    in-out property <brush> title: #BABABA;
}

global PanelPalette {
    in-out property <brush> background: #777777;
    in-out property <brush> border: #888888;
    in-out property <brush> title: #BABABA;
}

enum KnobCurve {
    linear,
    logarithmic,
}

component RotaryKnob inherits Rectangle {
    in property <float> minimum: 0.0;
    in property <float> maximum: 1.0;
    in property <float> step: 0.01;
    in-out property <float> value: minimum;
    in property <KnobCurve> curve: KnobCurve.linear;
    in property <string> label: "";
    in property <brush> bg_brush: KnobPalette.dial_bg;
    in property <brush> border_brush: KnobPalette.border;
    in property <brush> marker_brush: KnobPalette.marker;
    in property <brush> title_brush: KnobPalette.title;

    callback value_edited(float);

    width: 72px;
    height: 92px;

    private property <float> range: max(0.0001, root.maximum - root.minimum);
    private property <float> normalized: root.value_to_normalized(root.value);
    private property <angle> angle: 225deg - 270deg * root.normalized;
    private property <float> marker_radius: (dial.width / 2 - 6px) / 1px;

    VerticalLayout {
        spacing: 6px;
        padding: 0px;

        HorizontalLayout {
            spacing: 0px;

            Rectangle {
                horizontal-stretch: 1;
                width: 0px;
                height: 0px;
                opacity: 0.0;
            }

            dial := Rectangle {
                width: 64px;
                height: 64px;
                border-radius: 32px;
                border-width: 2px;
                border-color: root.border_brush;
                background: root.bg_brush;

                marker := Rectangle {
                    width: 6px;
                    height: 6px;
                    border-radius: 4px;
                    background: root.marker_brush;
                    x: parent.width / 2 + Math.cos(root.angle) * (root.marker_radius * 1px) - self.width / 2;
                    y: parent.height / 2 - Math.sin(root.angle) * (root.marker_radius * 1px) - self.height / 2;
                }

                TouchArea {
                    width: 100%;
                    height: 100%;
                    property <float> start-value: root.value;

                    pointer-event(event) => {
                        if (event.button != PointerEventButton.left) {
                            return;
                        }
                        if (event.kind == PointerEventKind.down) {
                            self.start-value = root.value;
                        } else if (event.kind == PointerEventKind.up) {
                            root.value_edited(root.value);
                        }
                    }

                    moved => {
                        let delta_px = (self.pressed-y - self.mouse-y) / 1px;
                        let delta = delta_px / 150.0;
                        root.update_value_by_normalized_delta(self.start-value, delta);
                    }
                }
            }

            Rectangle {
                horizontal-stretch: 1;
                width: 0px;
                height: 0px;
                opacity: 0.0;
            }
        }

        Text {
            text: root.label;
            horizontal-alignment: left;
            font-size: 12px;
            font-weight: 500;
            color: root.title_brush;
        }
    }

    function update_value(new-value: float) {
        let clamped = max(root.minimum, min(root.maximum, new-value));
        let snapped = quantize(clamped);

        if (snapped == root.value) {
            return;
        }
        root.value = snapped;
        root.value_edited(root.value);
    }

    function update_value_by_normalized_delta(start_value: float, delta: float) {
        let start_normalized = root.value_to_normalized(start_value);
        let normalized = max(0.0, min(1.0, start_normalized + delta));
        let new_value = root.normalized_to_value(normalized);
        root.update_value(new_value);
    }

    function quantize(value: float) -> float {
        if (root.step <= 0) {
            return value;
        }
        let steps = Math.round((value - root.minimum) / root.step);
        return root.minimum + steps * root.step;
    }

    function value_to_normalized(value: float) -> float {
        let clamped = max(root.minimum, min(root.maximum, value));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return max(0.0, min(1.0, (Math.log(clamped, MathConstants.natural_log_base) - min_log) / (max_log - min_log)));
            }
        }
        return max(0.0, min(1.0, (clamped - root.minimum) / root.range));
    }

    function normalized_to_value(normalized: float) -> float {
        let clamped = max(0.0, min(1.0, normalized));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return Math.exp(min_log + (max_log - min_log) * clamped);
            }
        }
        return root.minimum + clamped * root.range;
    }
}

component Panel inherits Rectangle {
    in property <string> title: "";
    in property <length> content_padding: 16px;
    in property <length> content_spacing: 12px;
    in property <length> corner_radius: 8px;
    in property <length> border_thickness: 3px;
    in property <brush> bg_brush: PanelPalette.background;
    in property <brush> border_brush: PanelPalette.border;
    in property <brush> title_brush: PanelPalette.title;

    border-radius: root.corner_radius;
    border-width: root.border_thickness;
    border-color: root.border_brush;
    background: root.bg_brush;

    layout := VerticalLayout {
        padding-left: root.content_padding;
        padding-right: root.content_padding;
        padding-top: root.content_padding;
        padding-bottom: root.content_padding;
        spacing: root.content_spacing;

        if root.title != "": Text {
            text: root.title;
            font-weight: 600;
            font-size: 14px;
            color: root.title_brush;
        }

        @children
    }

    height: layout.preferred-height;
}

export component SynthWindow inherits Window {
    title: "Oscen";
    background: #666666;

    in-out property <float> carrier_frequency: 440.0;
    in-out property <float> modulator_frequency: 100.0;
    in-out property <float> cutoff_frequency: 3000.0;
    in-out property <float> q_factor: 0.707;

    callback carrier_frequency_edited(float);
    callback modulator_frequency_edited(float);
    callback cutoff_frequency_edited(float);
    callback q_factor_edited(float);

    root_layout := VerticalLayout {
        padding-left: 16px;
        padding-right: 16px;
        padding-top: 16px;
        padding-bottom: 16px;
        spacing: 16px;

        HorizontalLayout {
            spacing: 16px;
            alignment: start;

            Panel {
                horizontal-stretch: 1;
                min-width: 240px;
                vertical-stretch: 0;
                title: "Oscillator";

                RotaryKnob {
                    label: "Frequency";
                    minimum: 10.0;
                    maximum: 2000.0;
                    step: 1.0;
                    vertical-stretch: 0;
                    value: root.carrier_frequency;
                    value_edited(value) => {
                        root.carrier_frequency = value;
                        root.carrier_frequency_edited(value);
                    }
                }
            }

            Panel {
                horizontal-stretch: 1;
                min-width: 240px;
                vertical-stretch: 0;
                title: "Filter";
                bg_brush: #629460;
                border_brush: #96BE8C;
                title_brush: #C9F2C7;

                RotaryKnob {
                    label: "Cutoff";
                    minimum: 20.0;
                    maximum: 20000.0;
                    step: 1.0;
                    curve: KnobCurve.logarithmic;
                    vertical-stretch: 0;
                    value: root.cutoff_frequency;
                    value_edited(value) => {
                        root.cutoff_frequency = value;
                        root.cutoff_frequency_edited(value);
                    }
                }

                RotaryKnob {
                    label: "Q";
                    minimum: 0.1;
                    maximum: 10.0;
                    step: 0.001;
                    vertical-stretch: 0;
                    value: root.q_factor;
                    value_edited(value) => {
                        root.q_factor = value;
                        root.q_factor_edited(value);
                    }
                }
            }
        }
    }

    preferred-width: root_layout.preferred-width;
    preferred-height: root_layout.preferred-height;
    min-width: root_layout.preferred-width;
    min-height: root_layout.preferred-height;
    max-width: root_layout.preferred-width;
    max-height: root_layout.preferred-height;
}
