// ===== Math Constants =====
global MathConstants {
    out property <float> natural_log_base: 2.718281828459045;
}

// ===== Data Structures =====
export struct Connection {
    from: int,
    to: int,
}

struct JackInfo {
    id: int,
    x: length,
    y: length,
    is_input: bool,
}

// ===== Theme & Styling =====
global Theme {
    // Colors
    out property <brush> window_bg: #222222;
    out property <brush> node_bg: #629460;
    out property <brush> node_border: #96BE8C;
    out property <brush> node_title: #C9F2C7;
    out property <brush> knob_dial: #A9A9A9;
    out property <brush> knob_border: #96BE8C;
    out property <brush> knob_marker: #777777;
    out property <brush> knob_label: #C9F2C7;
    out property <brush> jack_circle: #D4AF37;
    out property <brush> jack_border: #B8960A;
    out property <brush> jack_label: #BABABA;
    out property <brush> jack_hover_highlight: #FFD700;
    out property <brush> scope_bg: #1B2420;
    out property <brush> header_text: #EEEEEE;
    out property <brush> instructions_text: #CCCCCC;

    // Cable colors by jack type
    out property <color> cable_sine: #FF6B6B;
    out property <color> cable_saw: #4ECDC4;
    out property <color> cable_filter: #FFE66D;
    out property <color> cable_scope: #8AC6FF;
    out property <color> cable_default: #CCCCCC;
}

global Dimensions {
    // Knob dimensions
    out property <length> knob_dial_size: 36px;
    out property <length> knob_height: 55px;
    out property <length> knob_spacing: 10px;
    out property <length> knob_label_size: 9px;
    out property <int> knobs_per_row: 3;

    // Jack dimensions
    out property <length> jack_width: 30px;
    out property <length> jack_height: 40px;
    out property <length> jack_circle_size: 20px;
    out property <length> jack_h_padding: 5px;
    out property <length> jack_circle_y: 2px;
    out property <length> jack_label_y: 24px;
    out property <length> jack_label_size: 9px;
    out property <length> jack_spacing: 2px;

    // Calculate jack center offset (circle_y + radius)
    out property <length> jack_center_offset: 12px;

    // Node dimensions
    out property <length> node_width: 160px;
    out property <length> node_border_radius: 6px;
    out property <length> node_border_width: 2px;
    out property <length> node_title_y: 12px;
    out property <length> node_title_size: 12px;
    out property <length> node_content_padding: 10px;
    out property <length> node_drag_handle_height: 32px;
    out property <length> knob_area_y: 32px;
    out property <length> knobs_bottom_padding: 2px;

    // Cable dimensions
    out property <length> cable_width: 2px;
    out property <length> cable_control_offset: 60px;

    // Drag sensitivity
    out property <float> knob_drag_sensitivity: 120.0;
}

// ===== Components =====

enum KnobCurve {
    linear,
    logarithmic,
}

component Knob inherits Rectangle {
    // Public interface
    in property <float> minimum: 0.0;
    in property <float> maximum: 1.0;
    in-out property <float> value: minimum;
    in property <KnobCurve> curve: KnobCurve.linear;
    in property <string> label: "";
    callback value_edited(float);

    // Private computed properties
    private property <float> range: max(0.0001, root.maximum - root.minimum);
    private property <float> normalized: root.value_to_normalized(root.value);
    private property <angle> angle: 225deg - 270deg * root.normalized;
    private property <length> marker_offset: Dimensions.knob_dial_size / 2 - 4px;

    width: Dimensions.knob_dial_size;
    height: Dimensions.knob_height;

    VerticalLayout {
        spacing: 2px;
        padding: 0px;
        alignment: center;

        dial := Rectangle {
            width: Dimensions.knob_dial_size;
            height: Dimensions.knob_dial_size;
            border-radius: Dimensions.knob_dial_size / 2;
            border-width: 2px;
            border-color: Theme.knob_border;
            background: Theme.knob_dial;

            marker := Rectangle {
                width: 4px;
                height: 4px;
                border-radius: 2px;
                background: Theme.knob_marker;
                x: parent.width / 2 + Math.cos(root.angle) * root.marker_offset - self.width / 2;
                y: parent.height / 2 - Math.sin(root.angle) * root.marker_offset - self.height / 2;
            }

            TouchArea {
                width: 100%;
                height: 100%;
                property <float> start-value: root.value;

                pointer-event(event) => {
                    if (event.button != PointerEventButton.left) {
                        return;
                    }
                    if (event.kind == PointerEventKind.down) {
                        self.start-value = root.value;
                    } else if (event.kind == PointerEventKind.up) {
                        root.value_edited(root.value);
                    }
                }

                moved => {
                    let delta_px = (self.pressed-y - self.mouse-y) / 1px;
                    let delta = delta_px / Dimensions.knob_drag_sensitivity;
                    root.update_value_by_normalized_delta(self.start-value, delta);
                }
            }
        }

        Text {
            text: root.label;
            horizontal-alignment: center;
            font-size: Dimensions.knob_label_size;
            font-weight: 500;
            color: Theme.knob_label;
            width: 100%;
        }
    }

    function update_value_by_normalized_delta(start_value: float, delta: float) {
        let start_normalized = root.value_to_normalized(start_value);
        let normalized = max(0.0, min(1.0, start_normalized + delta));
        let new_value = root.normalized_to_value(normalized);
        let clamped = max(root.minimum, min(root.maximum, new_value));

        if (clamped != root.value) {
            root.value = clamped;
            root.value_edited(root.value);
        }
    }

    function value_to_normalized(value: float) -> float {
        let clamped = max(root.minimum, min(root.maximum, value));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return max(0.0, min(1.0, (Math.log(clamped, MathConstants.natural_log_base) - min_log) / (max_log - min_log)));
            }
        }
        return max(0.0, min(1.0, (clamped - root.minimum) / root.range));
    }

    function normalized_to_value(normalized: float) -> float {
        let clamped = max(0.0, min(1.0, normalized));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return Math.exp(min_log + (max_log - min_log) * clamped);
            }
        }
        return root.minimum + clamped * root.range;
    }
}

component Jack inherits Rectangle {
    // Public interface
    in property <string> label: "";
    in property <bool> is_output: false;
    in property <int> jack_id: -1;
    in property <bool> is_hovered: false;

    callback clicked(int);
    callback drag_started(int, length, length);
    callback dragged(int, length, length);
    callback drag_finished(int, length, length);

    // Dimensions from global
    width: Dimensions.jack_width;
    height: Dimensions.jack_height;

    // Make the entire jack clickable
    TouchArea {
        width: 100%;
        height: 100%;
        property <bool> is_pressing: false;
        property <bool> drag_active: false;

        clicked => {
            debug("Jack TouchArea clicked:", root.jack_id);
            root.clicked(root.jack_id);
        }

        pointer-event(event) => {
            if (event.button != PointerEventButton.left) {
                return;
            }
            if (event.kind == PointerEventKind.down) {
                if (root.is_output) {
                    self.is_pressing = true;
                    self.drag_active = false;
                }
            } else if (event.kind == PointerEventKind.up || event.kind == PointerEventKind.cancel) {
                if (self.drag_active) {
                    root.drag_finished(root.jack_id, self.mouse-x, self.mouse-y);
                }
                self.is_pressing = false;
                self.drag_active = false;
            }
        }

        moved => {
            if (!self.is_pressing || !root.is_output) {
                return;
            }
            if (!self.drag_active) {
                self.drag_active = true;
                root.drag_started(root.jack_id, self.pressed-x, self.pressed-y);
            }
            root.dragged(root.jack_id, self.mouse-x, self.mouse-y);
        }
    }

    // Jack circle
    circle := Rectangle {
        width: Dimensions.jack_circle_size;
        height: Dimensions.jack_circle_size;
        border-radius: Dimensions.jack_circle_size / 2;
        border-width: 2px;
        border-color: root.is_hovered ? Theme.jack_hover_highlight : Theme.jack_border;
        background: Theme.jack_circle;
        x: root.is_output ? (Dimensions.jack_width - Dimensions.jack_circle_size - Dimensions.jack_h_padding) : Dimensions.jack_h_padding;
        y: Dimensions.jack_circle_y;

        // Subtle animation for hover feedback
        animate border-color { duration: 150ms; }
    }

    // Label below circle
    Text {
        text: root.label;
        color: Theme.jack_label;
        font-size: Dimensions.jack_label_size;
        horizontal-alignment: center;
        x: 0px;
        y: Dimensions.jack_label_y;
        width: 100%;
    }
}

component ModuleNode inherits Rectangle {
    // Public interface
    in property <string> node_title: "";
    in property <[{label: string, jack_id: int}]> inputs: [];
    in property <[{label: string, jack_id: int}]> outputs: [];
    in property <length> extra_height: 0px;
    in property <[{minimum: float, maximum: float, value: float, curve: KnobCurve, label: string, knob_index: int}]> knobs: [];

    callback jack_clicked(int);
    callback knob_changed(int, float);
    callback position_changed(length, length);
    callback jack_drag_started(int, length, length);
    callback jack_dragged(int, length, length);
    callback jack_drag_finished(int, length, length);

    // Private layout calculations
    private property <int> knob_rows: root.knobs.length == 0 ? 0 : ((root.knobs.length - 1) / Dimensions.knobs_per_row + 1);
    private property <length> knobs_area_height: root.knob_rows * Dimensions.knob_height;
    private property <length> jacks_y: Dimensions.knob_area_y + root.knobs_area_height + Dimensions.knobs_bottom_padding + Dimensions.jack_spacing + root.extra_height;

    // Node styling
    width: Dimensions.node_width;
    height: root.jacks_y + Dimensions.jack_height;
    border-radius: Dimensions.node_border_radius;
    border-width: Dimensions.node_border_width;
    border-color: Theme.node_border;
    background: Theme.node_bg;

    // Drag handle for moving the node
    drag_handle := TouchArea {
        x: 0px;
        y: 0px;
        width: parent.width;
        height: Dimensions.node_drag_handle_height;
        property <bool> dragging: false;

        pointer-event(event) => {
            if (event.button != PointerEventButton.left) {
                return;
            }
            if (event.kind == PointerEventKind.down) {
                self.dragging = true;
            } else if (event.kind == PointerEventKind.up || event.kind == PointerEventKind.cancel) {
                self.dragging = false;
            }
        }

        moved => {
            if (!self.dragging) {
                return;
            }
            let dx = self.mouse-x - self.pressed-x;
            let dy = self.mouse-y - self.pressed-y;
            root.position_changed(root.x + dx, root.y + dy);
        }
    }

    // Title
    Text {
        text: root.node_title;
        font-weight: 600;
        font-size: Dimensions.node_title_size;
        color: Theme.node_title;
        horizontal-alignment: center;
        x: 0px;
        y: Dimensions.node_title_y;
        width: root.width;
    }

    // Render knobs in a grid
    for knob[index] in root.knobs: Knob {
        x: Dimensions.node_content_padding + (mod(index, Dimensions.knobs_per_row) * 1px) * (Dimensions.knob_dial_size + Dimensions.knob_spacing) / 1px;
        y: Dimensions.knob_area_y + (floor(index / Dimensions.knobs_per_row) * 1px) * Dimensions.knob_height / 1px;
        minimum: knob.minimum;
        maximum: knob.maximum;
        value: knob.value;
        curve: knob.curve;
        label: knob.label;
        value_edited(val) => {
            root.knob_changed(knob.knob_index, val);
        }
    }

    // Output jacks - positioned on the right
    if root.outputs.length > 0: Jack {
        x: root.width - Dimensions.node_content_padding - Dimensions.jack_width;
        y: root.jacks_y;
        label: root.outputs[0].label;
        is_output: true;
        jack_id: root.outputs[0].jack_id;
        clicked(id) => {
            root.jack_clicked(id);
        }
        drag_started(id, local_x, local_y) => {
            // Pass jack ID; parent will look up position from registry
            root.jack_drag_started(id, 0px, 0px);
        }
        dragged(id, local_x, local_y) => {
            let abs_x = root.x + root.width - Dimensions.node_content_padding - Dimensions.jack_width + local_x;
            let abs_y = root.y + root.jacks_y + local_y;
            root.jack_dragged(id, abs_x, abs_y);
        }
        drag_finished(id, local_x, local_y) => {
            let abs_x = root.x + root.width - Dimensions.node_content_padding - Dimensions.jack_width + local_x;
            let abs_y = root.y + root.jacks_y + local_y;
            root.jack_drag_finished(id, abs_x, abs_y);
        }
    }

    // Input jacks - positioned on the left
    if root.inputs.length > 0: Jack {
        x: Dimensions.node_content_padding;
        y: root.jacks_y;
        label: root.inputs[0].label;
        is_output: false;
        jack_id: root.inputs[0].jack_id;
        clicked(id) => {
            root.jack_clicked(id);
        }
    }
}

component Cable inherits Path {
    // Public interface
    in property <length> x1;
    in property <length> y1;
    in property <length> x2;
    in property <length> y2;
    in property <color> cable_color: Theme.cable_default;

    width: 900px;
    height: 600px;
    viewbox-width: 900;
    viewbox-height: 600;
    z: 10;

    stroke: root.cable_color;
    stroke-width: Dimensions.cable_width;
    stroke-line-cap: round;

    MoveTo {
        x: root.x1 / 1px;
        y: root.y1 / 1px;
    }

    CubicTo {
        x: root.x2 / 1px;
        y: root.y2 / 1px;
        control-1-x: (root.x1 / 1px) + Dimensions.cable_control_offset / 1px;
        control-1-y: root.y1 / 1px;
        control-2-x: (root.x2 / 1px) - Dimensions.cable_control_offset / 1px;
        control-2-y: root.y2 / 1px;
    }
}

// ===== Main Window =====

export component ModularWindow inherits Window {
    title: "Oscen Modular";
    background: Theme.window_bg;
    preferred-width: 900px;
    preferred-height: 600px;

    // ===== Public Interface =====

    // Callbacks for patching
    callback connect(int, int);
    callback disconnect(int, int);
    pure callback disconnect_all_from_output(int);

    // Callbacks for parameter changes
    callback sine_freq_changed(float);
    callback saw_freq_changed(float);
    callback filter_cutoff_changed(float);
    callback filter_q_changed(float);
    callback volume_level_changed(float);

    // Callback for node position changes
    callback node_moved();

    // Properties
    in-out property <[Connection]> connections: [];
    in-out property <image> scope_waveform;

    // Node positions (exposed for Rust to read)
    in-out property <length> sine_x: 80px;
    in-out property <length> sine_y: 120px;
    in-out property <length> saw_x: 80px;
    in-out property <length> saw_y: 310px;
    in-out property <length> filter_x: 340px;
    in-out property <length> filter_y: 220px;
    in-out property <length> scope_x: 580px;
    in-out property <length> scope_y: 80px;
    in-out property <length> output_x: 580px;
    in-out property <length> output_y: 320px;

    // Node widths (exposed for Rust to read)
    in-out property <length> sine_width: Dimensions.node_width;
    in-out property <length> saw_width: Dimensions.node_width;
    in-out property <length> filter_width: Dimensions.node_width;
    in-out property <length> scope_width: 340px;
    in-out property <length> output_width: Dimensions.node_width;

    // ===== Internal State =====

    // Cable drag state
    in-out property <bool> active_jack_drag: false;
    in-out property <int> drag_from_jack: -1;
    in-out property <int> hovered_input_jack: -1;
    in-out property <length> drag_start_x: 0px;
    in-out property <length> drag_start_y: 0px;
    in-out property <length> drag_cursor_x: 0px;
    in-out property <length> drag_cursor_y: 0px;

    // Jack registry - populated from Rust
    in-out property <[JackInfo]> jack_registry: [];

    // Helper function - direct array lookup
    pure function get_jack_info(jack_id: int) -> JackInfo {
        if (jack_id >= 0 && jack_id < root.jack_registry.length) {
            return root.jack_registry[jack_id];
        }
        return { id: -1, x: 0px, y: 0px, is_input: false };
    }

    // ===== UI Layout =====

    // Title
    Text {
        text: "Oscen";
        font-size: 18px;
        font-weight: 700;
        color: Theme.header_text;
        x: 0px;
        y: 20px;
        width: root.width;
        horizontal-alignment: center;
    }

    // Instructions
    Text {
        text: "Drag from an output to an input to connect, or click to toggle.";
        font-size: 12px;
        color: Theme.instructions_text;
        x: 0px;
        y: 550px;
        width: root.width;
        horizontal-alignment: center;
    }

    function clamp_length(value: length, min_value: length, max_value: length) -> length {
        return max(min_value, min(max_value, value));
    }

    function start_cable_drag(from_jack_id: int, start_x: length, start_y: length) {
        // Validate that this is an output jack
        let jack_info = root.get_jack_info(from_jack_id);
        if (jack_info.id < 0 || jack_info.is_input) {
            return;
        }

        // Disconnect existing connections from this output
        root.disconnect_all_from_output(from_jack_id);

        // Use jack center from registry for consistent positioning
        let jack_x = root.jack_registry[from_jack_id].x;
        let jack_y = root.jack_registry[from_jack_id].y;

        root.active_jack_drag = true;
        root.drag_from_jack = from_jack_id;
        root.hovered_input_jack = -1;
        root.drag_start_x = jack_x;
        root.drag_start_y = jack_y;
        root.drag_cursor_x = jack_x;
        root.drag_cursor_y = jack_y;
    }

    function update_cable_drag(jack_id: int, cursor_x: length, cursor_y: length) {
        if (!root.active_jack_drag) {
            return;
        }
        let hovered = root.hit_test_input(cursor_x, cursor_y);
        root.hovered_input_jack = hovered;

        if (hovered >= 0) {
            // Snap to the hovered jack's position
            let jack_info = root.get_jack_info(hovered);
            root.drag_cursor_x = jack_info.x;
            root.drag_cursor_y = jack_info.y;
        } else {
            root.drag_cursor_x = cursor_x;
            root.drag_cursor_y = cursor_y;
        }
    }

    function finish_cable_drag(jack_id: int, cursor_x: length, cursor_y: length) {
        if (!root.active_jack_drag) {
            return;
        }

        let target = root.hovered_input_jack;
        if (target >= 0) {
            // Complete connection to the hovered input jack
            let jack_info = root.get_jack_info(target);
            root.drag_cursor_x = jack_info.x;
            root.drag_cursor_y = jack_info.y;
            root.handle_jack_click(target);
        } else {
            // No target, cancel the drag
            root.drag_cursor_x = cursor_x;
            root.drag_cursor_y = cursor_y;
            root.drag_from_jack = -1;
        }

        root.active_jack_drag = false;
        root.hovered_input_jack = -1;
    }

    function hit_test_input(cursor_x: length, cursor_y: length) -> int {
        let half_width = Dimensions.jack_width / 2;

        // Test input jacks from the registry (IDs 2, 4, 5)
        // Note: Slint doesn't support loops in functions, so we check known input jacks

        // Filter input (id: 2)
        if (root.jack_registry.length > 2 && root.jack_registry[2].is_input) {
            let left = root.jack_registry[2].x - half_width;
            let top = root.jack_registry[2].y - Dimensions.jack_center_offset;
            if (cursor_x >= left && cursor_x <= left + Dimensions.jack_width &&
                cursor_y >= top && cursor_y <= top + Dimensions.jack_height) {
                return 2;
            }
        }

        // Output input (id: 4)
        if (root.jack_registry.length > 4 && root.jack_registry[4].is_input) {
            let left = root.jack_registry[4].x - half_width;
            let top = root.jack_registry[4].y - Dimensions.jack_center_offset;
            if (cursor_x >= left && cursor_x <= left + Dimensions.jack_width &&
                cursor_y >= top && cursor_y <= top + Dimensions.jack_height) {
                return 4;
            }
        }

        // Scope input (id: 5)
        if (root.jack_registry.length > 5 && root.jack_registry[5].is_input) {
            let left = root.jack_registry[5].x - half_width;
            let top = root.jack_registry[5].y - Dimensions.jack_center_offset;
            if (cursor_x >= left && cursor_x <= left + Dimensions.jack_width &&
                cursor_y >= top && cursor_y <= top + Dimensions.jack_height) {
                return 5;
            }
        }

        return -1;
    }

    // ===== Helper Functions =====

    function cable_color_for_jack(jack_id: int) -> color {
        if (jack_id == 0) { return Theme.cable_sine; }
        if (jack_id == 1) { return Theme.cable_saw; }
        if (jack_id == 3) { return Theme.cable_filter; }
        if (jack_id == 6) { return Theme.cable_scope; }
        return Theme.cable_default;
    }

    function drag_preview_color() -> color {
        return root.cable_color_for_jack(root.drag_from_jack);
    }

    // Sine Oscillator Node
    sine_node := ModuleNode {
        x: root.sine_x;
        y: root.sine_y;
        node_title: "Sine Osc";
        outputs: [{label: "Out", jack_id: 0}];
        knobs: [{
            minimum: 20.0,
            maximum: 2000.0,
            value: 220.0,
            curve: KnobCurve.logarithmic,
            label: "Freq",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.sine_freq_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - sine_node.width);
            let max_y = max(0px, root.height - sine_node.height);
            root.sine_x = clamp_length(nx, 0px, max_x);
            root.sine_y = clamp_length(ny, 0px, max_y);
            root.node_moved();
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Saw Oscillator Node
    saw_node := ModuleNode {
        x: root.saw_x;
        y: root.saw_y;
        node_title: "Saw Osc";
        outputs: [{label: "Out", jack_id: 1}];
        knobs: [{
            minimum: 20.0,
            maximum: 2000.0,
            value: 440.0,
            curve: KnobCurve.logarithmic,
            label: "Freq",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.saw_freq_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - saw_node.width);
            let max_y = max(0px, root.height - saw_node.height);
            root.saw_x = clamp_length(nx, 0px, max_x);
            root.saw_y = clamp_length(ny, 0px, max_y);
            root.node_moved();
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Filter Node
    filter_node := ModuleNode {
        x: root.filter_x;
        y: root.filter_y;
        node_title: "Filter";
        inputs: [{label: "In", jack_id: 2}];
        outputs: [{label: "Out", jack_id: 3}];
        knobs: [
            {
                minimum: 100.0,
                maximum: 10000.0,
                value: 1000.0,
                curve: KnobCurve.logarithmic,
                label: "Cutoff",
                knob_index: 0
            },
            {
                minimum: 0.1,
                maximum: 10.0,
                value: 0.707,
                curve: KnobCurve.logarithmic,
                label: "Q",
                knob_index: 1
            }
        ];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => {
            if (idx == 0) {
                root.filter_cutoff_changed(val);
            } else if (idx == 1) {
                root.filter_q_changed(val);
            }
        }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - filter_node.width);
            let max_y = max(0px, root.height - filter_node.height);
            root.filter_x = clamp_length(nx, 0px, max_x);
            root.filter_y = clamp_length(ny, 0px, max_y);
            root.node_moved();
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Oscilloscope Node
    scope_node := ModuleNode {
        x: root.scope_x;
        y: root.scope_y;
        width: 340px;
        node_title: "Scope";
        inputs: [{label: "In", jack_id: 5}];
        outputs: [{label: "Out", jack_id: 6}];
        knobs: [];
        extra_height: 120px;
        jack_clicked(id) => { handle_jack_click(id); }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - scope_node.width);
            let max_y = max(0px, root.height - scope_node.height);
            root.scope_x = clamp_length(nx, 0px, max_x);
            root.scope_y = clamp_length(ny, 0px, max_y);
            root.node_moved();
        }

        Rectangle {
            x: Dimensions.node_content_padding;
            y: Dimensions.knob_area_y;
            width: parent.width - (2 * Dimensions.node_content_padding);
            height: max(40px, parent.height - 74px);
            background: Theme.scope_bg;
            border-radius: 4px;
            clip: true;

            Image {
                x: 0px;
                y: 0px;
                width: 100%;
                height: 100%;
                source: root.scope_waveform;
            }
        }
    }

    // Output Node
    output_node := ModuleNode {
        x: root.output_x;
        y: root.output_y;
        node_title: "Output";
        inputs: [{label: "In", jack_id: 4}];
        knobs: [{
            minimum: 0.0,
            maximum: 1.0,
            value: 0.8,
            curve: KnobCurve.linear,
            label: "Level",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.volume_level_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - output_node.width);
            let max_y = max(0px, root.height - output_node.height);
            root.output_x = clamp_length(nx, 0px, max_x);
            root.output_y = clamp_length(ny, 0px, max_y);
            root.node_moved();
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Draw cables dynamically based on connections array
    // Positions are provided by Rust jack registry
    for conn in root.connections: Cable {
        x1: root.jack_registry[conn.from].x;
        y1: root.jack_registry[conn.from].y;
        x2: root.jack_registry[conn.to].x;
        y2: root.jack_registry[conn.to].y;
        cable_color: root.cable_color_for_jack(conn.from);
    }

    if root.active_jack_drag: Cable {
        x1: root.drag_start_x;
        y1: root.drag_start_y;
        x2: root.drag_cursor_x;
        y2: root.drag_cursor_y;
        cable_color: root.drag_preview_color();
    }

    // ===== Event Handlers =====

    function handle_jack_click(jack_id: int) {
        debug("handle_jack_click called with:", jack_id);

        let jack_info = root.get_jack_info(jack_id);
        if (jack_info.id < 0) {
            return; // Invalid jack ID
        }

        if (root.drag_from_jack == -1) {
            // First click - disconnect all from this output and start drag
            if (!jack_info.is_input) {
                debug("Disconnecting output:", jack_id);
                root.disconnect_all_from_output(jack_id);
            }
            // Start dragging from this jack
            debug("Starting drag from:", jack_id);
            root.drag_from_jack = jack_id;
        } else {
            // Complete the connection
            let from = root.drag_from_jack;
            let to = jack_id;
            debug("Completing connection:", from, "->", to);

            // Validate connection using jack registry
            let from_info = root.get_jack_info(from);
            let to_info = root.get_jack_info(to);

            if (!from_info.is_input && to_info.is_input) {
                // Valid: output to input
                debug("Valid connection, calling connect");
                root.connect(from, to);
            } else {
                debug("Invalid connection");
            }

            root.drag_from_jack = -1;
        }
    }
}
