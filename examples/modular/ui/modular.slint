
global MathConstants {
    out property <float> natural_log_base: 2.718281828459045;
}

global PanelPalette {
    in-out property <brush> background: #777777;
    in-out property <brush> border: #888888;
    in-out property <brush> title: #BABABA;
    in-out property <brush> jack: #D4AF37;
    in-out property <brush> jack_border: #B8960A;
}

enum KnobCurve {
    linear,
    logarithmic,
}

component Knob inherits Rectangle {
    in property <float> minimum: 0.0;
    in property <float> maximum: 1.0;
    in-out property <float> value: minimum;
    in property <KnobCurve> curve: KnobCurve.linear;
    in property <string> label: "";

    callback value_edited(float);

    private property <length> dial_size: 36px;
    private property <float> range: max(0.0001, root.maximum - root.minimum);
    private property <float> normalized: root.value_to_normalized(root.value);
    private property <angle> angle: 225deg - 270deg * root.normalized;
    private property <float> marker_radius: (root.dial_size / 2 - 4px) / 1px;

    width: root.dial_size;  // Match dial size
    height: 55px;

    VerticalLayout {
        spacing: 2px;
        padding: 0px;
        alignment: center;  // Center children horizontally

        dial := Rectangle {
            width: root.dial_size;
            height: root.dial_size;
            border-radius: root.dial_size / 2;
            border-width: 2px;
            border-color: #96BE8C;
            background: #A9A9A9;

            marker := Rectangle {
                width: 4px;
                height: 4px;
                border-radius: 2px;
                background: #777777;  // Match synth-slint marker color
                x: parent.width / 2 + Math.cos(root.angle) * (root.marker_radius * 1px) - self.width / 2;
                y: parent.height / 2 - Math.sin(root.angle) * (root.marker_radius * 1px) - self.height / 2;
            }

            TouchArea {
                width: 100%;
                height: 100%;
                property <float> start-value: root.value;

                pointer-event(event) => {
                    if (event.button != PointerEventButton.left) {
                        return;
                    }
                    if (event.kind == PointerEventKind.down) {
                        self.start-value = root.value;
                    } else if (event.kind == PointerEventKind.up) {
                        root.value_edited(root.value);
                    }
                }

                moved => {
                    let delta_px = (self.pressed-y - self.mouse-y) / 1px;
                    let delta = delta_px / 120.0;
                    root.update_value_by_normalized_delta(self.start-value, delta);
                }
            }
        }

        Text {
            text: root.label;
            horizontal-alignment: center;
            font-size: 9px;
            font-weight: 500;
            color: #C9F2C7;
            width: 100%;  // Take full width of parent
        }
    }

    function update_value_by_normalized_delta(start_value: float, delta: float) {
        let start_normalized = root.value_to_normalized(start_value);
        let normalized = max(0.0, min(1.0, start_normalized + delta));
        let new_value = root.normalized_to_value(normalized);
        let clamped = max(root.minimum, min(root.maximum, new_value));

        if (clamped != root.value) {
            root.value = clamped;
            root.value_edited(root.value);
        }
    }

    function value_to_normalized(value: float) -> float {
        let clamped = max(root.minimum, min(root.maximum, value));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return max(0.0, min(1.0, (Math.log(clamped, MathConstants.natural_log_base) - min_log) / (max_log - min_log)));
            }
        }
        return max(0.0, min(1.0, (clamped - root.minimum) / root.range));
    }

    function normalized_to_value(normalized: float) -> float {
        let clamped = max(0.0, min(1.0, normalized));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return Math.exp(min_log + (max_log - min_log) * clamped);
            }
        }
        return root.minimum + clamped * root.range;
    }
}

component Jack inherits Rectangle {
    in property <string> label: "";
    in property <bool> is_output: false;
    in property <int> jack_id: -1;

    callback clicked(int);
    callback drag_started(int, length /* local_x */, length /* local_y */);
    callback dragged(int, length /* local_x */, length /* local_y */);
    callback drag_finished(int, length /* local_x */, length /* local_y */);

    private property <length> h_padding: 5px;
    width: 30px;
    height: 40px;

    // Make the entire jack clickable
    TouchArea {
        width: 100%;
        height: 100%;
        property <bool> is_pressing: false;
        property <bool> drag_active: false;

        clicked => {
            debug("Jack TouchArea clicked:", root.jack_id);
            root.clicked(root.jack_id);
        }

        pointer-event(event) => {
            if (event.button != PointerEventButton.left) {
                return;
            }
            if (event.kind == PointerEventKind.down) {
                if (root.is_output) {
                    self.is_pressing = true;
                    self.drag_active = false;
                }
            } else if (event.kind == PointerEventKind.up || event.kind == PointerEventKind.cancel) {
                if (self.drag_active) {
                    root.drag_finished(root.jack_id, self.mouse-x, self.mouse-y);
                }
                self.is_pressing = false;
                self.drag_active = false;
            }
        }

        moved => {
            if (!self.is_pressing || !root.is_output) {
                return;
            }
            if (!self.drag_active) {
                self.drag_active = true;
                root.drag_started(root.jack_id, self.pressed-x, self.pressed-y);
            }
            root.dragged(root.jack_id, self.mouse-x, self.mouse-y);
        }
    }

    // Circle - positioned with padding from edge
    Rectangle {
        width: 20px;
        height: 20px;
        border-radius: 10px;
        border-width: 2px;
        border-color: PanelPalette.jack_border;
        background: PanelPalette.jack;
        x: root.is_output ? (10px - root.h_padding) : root.h_padding;  // Inset from edges
        y: 2px;
    }

    // Text below circle
    Text {
        text: root.label;
        color: PanelPalette.title;
        font-size: 9px;
        horizontal-alignment: center;
        x: 0px;
        y: 24px;
        width: 100%;
    }
}

component ModuleNode inherits Rectangle {
    in property <string> node_title: "";
    in property <[{label: string, jack_id: int}]> inputs: [];
    in property <[{label: string, jack_id: int}]> outputs: [];
    in property <length> extra_height: 0px;

    // Knob configurations - array of knobs
    in property <[{minimum: float, maximum: float, value: float, curve: KnobCurve, label: string, knob_index: int}]> knobs: [];

    callback jack_clicked(int);
    callback knob_changed(int /* knob_index */, float /* value */);
    callback position_changed(length /* new_x */, length /* new_y */);
    callback jack_drag_started(int /* jack_id */, length /* global_x */, length /* global_y */);
    callback jack_dragged(int /* jack_id */, length /* global_x */, length /* global_y */);
    callback jack_drag_finished(int /* jack_id */, length /* global_x */, length /* global_y */);

    // Layout constants
    private property <int> knobs_per_row: 3;
    private property <length> knob_width: 36px;
    private property <length> knob_height: 55px;
    private property <length> knob_spacing: 10px;
    private property <length> knob_area_y: 32px;
    private property <length> knobs_bottom_padding: 2px;
    private property <length> jack_spacing: 2px;
    private property <length> jack_width: 30px;
    private property <length> jack_height: 40px;
    private property <length> drag_handle_height: root.knob_area_y;

    // Calculate number of rows
    private property <int> knob_rows: root.knobs.length == 0 ? 0 : ((root.knobs.length - 1) / root.knobs_per_row + 1);

    // Calculate heights
    private property <length> knobs_area_height: root.knob_rows * root.knob_height;
    private property <length> jacks_y: root.knob_area_y + root.knobs_area_height + root.knobs_bottom_padding + root.jack_spacing + root.extra_height;

    width: 160px;
    height: root.jacks_y + root.jack_height;
    border-radius: 6px;
    border-width: 3px;
    border-color: #96BE8C;
    background: #629460;

    TouchArea {
        x: 0px;
        y: 0px;
        width: parent.width;
        height: root.drag_handle_height;
        property <bool> dragging: false;

        pointer-event(event) => {
            if (event.button != PointerEventButton.left) {
                return;
            }
            if (event.kind == PointerEventKind.down) {
                self.dragging = true;
            } else if (event.kind == PointerEventKind.up || event.kind == PointerEventKind.cancel) {
                self.dragging = false;
            }
        }

        moved => {
            if (!self.dragging) {
                return;
            }
            let dx = self.mouse-x - self.pressed-x;
            let dy = self.mouse-y - self.pressed-y;
            root.position_changed(root.x + dx, root.y + dy);
        }
    }

    // Render knobs in a grid
    for knob[index] in root.knobs: Knob {
        x: 10px + (mod(index, root.knobs_per_row) * (root.knob_width + root.knob_spacing));
        y: root.knob_area_y + (floor(index / root.knobs_per_row) * root.knob_height);
        minimum: knob.minimum;
        maximum: knob.maximum;
        value: knob.value;
        curve: knob.curve;
        label: knob.label;
        value_edited(val) => {
            root.knob_changed(knob.knob_index, val);
        }
    }

    // Jack element positions - with same padding as knobs
    private property <length> jack_x_padding: 10px;
    private property <length> output_jack_element_x: root.width - root.jack_width - root.jack_x_padding;
    private property <length> input_jack_element_x: root.jack_x_padding;
    private property <length> output_jack_element_y: root.jacks_y;
    private property <length> input_jack_element_y: root.jacks_y;

    // Expose cable connection points (center of jack circles)
    // Jack is 30px wide with 5px horizontal padding
    // Both circles positioned at x=5px (padding), center at 5 + 10 (radius) = 15px from jack left
    // Vertical: jack_y + 2px + circle_radius (10px) = jack_y + 12px
    out property <length> output_jack_x: root.output_jack_element_x + 15px;  // Padded circle center
    out property <length> output_jack_y: root.output_jack_element_y + 12px;
    out property <length> input_jack_x: root.input_jack_element_x + 15px;  // Padded circle center
    out property <length> input_jack_y: root.input_jack_element_y + 12px;

    // Title
    Text {
        text: root.node_title;
        font-weight: 600;
        font-size: 12px;
        color: #C9F2C7;
        horizontal-alignment: center;
        x: 0px;
        y: 12px;
        width: root.width;
    }

    // Output jacks - positioned absolutely on the right
    if root.outputs.length > 0: Jack {
        x: root.output_jack_element_x;
        y: root.output_jack_element_y;
        label: root.outputs[0].label;
        is_output: true;
        jack_id: root.outputs[0].jack_id;
        clicked(id) => {
            root.jack_clicked(id);
        }
        drag_started(id, local_x, local_y) => {
            // Start from the jack center to keep the virtual cable anchored
            root.jack_drag_started(id, root.x + root.output_jack_x, root.y + root.output_jack_y);
            root.jack_dragged(id, root.x + root.output_jack_element_x + local_x, root.y + root.output_jack_element_y + local_y);
        }
        dragged(id, local_x, local_y) => {
            root.jack_dragged(id, root.x + root.output_jack_element_x + local_x, root.y + root.output_jack_element_y + local_y);
        }
        drag_finished(id, local_x, local_y) => {
            root.jack_drag_finished(id, root.x + root.output_jack_element_x + local_x, root.y + root.output_jack_element_y + local_y);
        }
    }

    // Input jacks - positioned absolutely on the left
    if root.inputs.length > 0: Jack {
        x: root.input_jack_element_x;
        y: root.input_jack_element_y;
        label: root.inputs[0].label;
        is_output: false;
        jack_id: root.inputs[0].jack_id;
        clicked(id) => {
            root.jack_clicked(id);
        }
    }
}

component Cable inherits Path {
    in property <length> x1;
    in property <length> y1;
    in property <length> x2;
    in property <length> y2;
    in property <color> cable_color: #FF6B6B;

    width: 900px;
    height: 600px;
    viewbox-width: 900;
    viewbox-height: 600;
    z: 10;

    stroke: root.cable_color;
    stroke-width: 3px;
    stroke-line-cap: round;

    MoveTo {
        x: root.x1 / 1px;
        y: root.y1 / 1px;
    }

    CubicTo {
        x: root.x2 / 1px;
        y: root.y2 / 1px;
        // Horizontal bezier handles
        control-1-x: (root.x1 / 1px) + 60;
        control-1-y: root.y1 / 1px;
        control-2-x: (root.x2 / 1px) - 60;
        control-2-y: root.y2 / 1px;
    }
}

export component ModularWindow inherits Window {
    title: "Oscen Modular";
    background: #666666;
    preferred-width: 900px;
    preferred-height: 600px;

    // Test if ANY touch events work
    TouchArea {
        width: 100%;
        height: 100%;
        clicked => {
            debug("WINDOW CLICKED!");
        }
    }

    // Callbacks for patching
    callback connect(int /* from_jack_id */, int /* to_jack_id */);
    callback disconnect(int /* from_jack_id */, int /* to_jack_id */);

    // Internal drag state for cable creation
    in-out property <bool> active_jack_drag: false;
    in-out property <int> drag_from_jack_id: -1;
    in-out property <int> hovered_input_jack: -1;
    in-out property <length> drag_start_x: 0px;
    in-out property <length> drag_start_y: 0px;
    in-out property <length> drag_cursor_x: 0px;
    in-out property <length> drag_cursor_y: 0px;

    // Callbacks for parameter changes
    callback sine_freq_changed(float);
    callback saw_freq_changed(float);
    callback filter_cutoff_changed(float);
    callback filter_q_changed(float);
    callback volume_level_changed(float);

    // State for drag operation
    in-out property <int> drag_from_jack: -1;

    // Track individual connections for visual display
    in-out property <bool> conn_sine_filter: false;
    in-out property <bool> conn_sine_volume: false;
    in-out property <bool> conn_saw_filter: false;
    in-out property <bool> conn_saw_volume: false;
    in-out property <bool> conn_filter_volume: false;
    in-out property <bool> conn_sine_scope: false;
    in-out property <bool> conn_saw_scope: false;
    in-out property <bool> conn_filter_scope: false;
    in-out property <bool> conn_scope_output: false;

    in-out property <image> scope_waveform;

    // Title
    Text {
        text: "Oscen";
        font-size: 18px;
        font-weight: 700;
        color: #EEEEEE;
        x: 0px;
        y: 20px;
        width: root.width;
        horizontal-alignment: center;
    }

    // Instructions
    Text {
        text: "Drag from an output to an input to connect, or click to toggle.";
        font-size: 12px;
        color: #CCCCCC;
        x: 0px;
        y: 550px;
        width: root.width;
        horizontal-alignment: center;
    }

    function clamp_length(value: length, min_value: length, max_value: length) -> length {
        return max(min_value, min(max_value, value));
    }

    function start_cable_drag(from_jack_id: int, start_x: length, start_y: length) {
        if (!(from_jack_id == 0 || from_jack_id == 1 || from_jack_id == 3 || from_jack_id == 6)) {
            return;
        }

        if (root.output_has_connection(from_jack_id)) {
            root.disconnect_output(from_jack_id);
        }

        root.active_jack_drag = true;
        root.drag_from_jack = from_jack_id;
        root.drag_from_jack_id = from_jack_id;
        root.hovered_input_jack = -1;
        root.drag_start_x = start_x;
        root.drag_start_y = start_y;
        root.drag_cursor_x = start_x;
        root.drag_cursor_y = start_y;
    }

    function update_cable_drag(jack_id: int, cursor_x: length, cursor_y: length) {
        if (!root.active_jack_drag) {
            return;
        }
        let hovered = root.hit_test_input(cursor_x, cursor_y);
        root.hovered_input_jack = hovered;

        if (hovered == 2 || hovered == 4 || hovered == 5) {
            root.drag_cursor_x = root.jack_center_x(hovered);
            root.drag_cursor_y = root.jack_center_y(hovered);
        } else {
            root.drag_cursor_x = cursor_x;
            root.drag_cursor_y = cursor_y;
        }
    }

    function finish_cable_drag(jack_id: int, cursor_x: length, cursor_y: length) {
        if (!root.active_jack_drag) {
            return;
        }

        let target = root.hovered_input_jack;
        if (target == 2 || target == 4 || target == 5) {
            root.drag_cursor_x = root.jack_center_x(target);
            root.drag_cursor_y = root.jack_center_y(target);
            root.handle_jack_click(target);
        } else {
            root.drag_cursor_x = cursor_x;
            root.drag_cursor_y = cursor_y;
            root.drag_from_jack = -1;
        }

        root.active_jack_drag = false;
        root.drag_from_jack_id = -1;
        root.hovered_input_jack = -1;
    }

    function jack_center_x(jack_id: int) -> length {
        if (jack_id == 0) { return sine_x + sine_node.output_jack_x; }
        if (jack_id == 1) { return saw_x + saw_node.output_jack_x; }
        if (jack_id == 2) { return filter_x + filter_node.input_jack_x; }
        if (jack_id == 3) { return filter_x + filter_node.output_jack_x; }
        if (jack_id == 4) { return output_x + output_node.input_jack_x; }
        if (jack_id == 5) { return scope_x + scope_node.input_jack_x; }
        if (jack_id == 6) { return scope_x + scope_node.output_jack_x; }
        return 0px;
    }

    function jack_center_y(jack_id: int) -> length {
        if (jack_id == 0) { return sine_y + sine_node.output_jack_y; }
        if (jack_id == 1) { return saw_y + saw_node.output_jack_y; }
        if (jack_id == 2) { return filter_y + filter_node.input_jack_y; }
        if (jack_id == 3) { return filter_y + filter_node.output_jack_y; }
        if (jack_id == 4) { return output_y + output_node.input_jack_y; }
        if (jack_id == 5) { return scope_y + scope_node.input_jack_y; }
        if (jack_id == 6) { return scope_y + scope_node.output_jack_y; }
        return 0px;
    }

    function hit_test_input(cursor_x: length, cursor_y: length) -> int {
        let jack_width = 30px;
        let jack_height = 40px;
        let half_width = jack_width / 2;
        let top_offset = 12px; // Center is 12px from top edge

        // Filter input (jack_id = 2)
        let filter_center_x = root.jack_center_x(2);
        let filter_center_y = root.jack_center_y(2);
        let filter_left = filter_center_x - half_width;
        let filter_top = filter_center_y - top_offset;

        if (cursor_x >= filter_left && cursor_x <= filter_left + jack_width &&
            cursor_y >= filter_top && cursor_y <= filter_top + jack_height) {
            return 2;
        }

        // Scope input (jack_id = 5)
        let scope_center_x = root.jack_center_x(5);
        let scope_center_y = root.jack_center_y(5);
        let scope_left = scope_center_x - half_width;
        let scope_top = scope_center_y - top_offset;

        if (cursor_x >= scope_left && cursor_x <= scope_left + jack_width &&
            cursor_y >= scope_top && cursor_y <= scope_top + jack_height) {
            return 5;
        }

        // Output input (jack_id = 4)
        let output_center_x = root.jack_center_x(4);
        let output_center_y = root.jack_center_y(4);
        let output_left = output_center_x - half_width;
        let output_top = output_center_y - top_offset;

        if (cursor_x >= output_left && cursor_x <= output_left + jack_width &&
            cursor_y >= output_top && cursor_y <= output_top + jack_height) {
            return 4;
        }

        return -1;
    }

    function drag_preview_color() -> color {
        if (root.drag_from_jack_id == 0) { return #FF6B6B; }
        if (root.drag_from_jack_id == 1) { return #4ECDC4; }
        if (root.drag_from_jack_id == 3) { return #FFE66D; }
        if (root.drag_from_jack_id == 6) { return #8AC6FF; }
        return #CCCCCC;
    }

    // Define node positions
    property <length> sine_x: 80px;
    property <length> sine_y: 120px;
    property <length> saw_x: 80px;
    property <length> saw_y: 310px;
    property <length> filter_x: 340px;
    property <length> filter_y: 220px;
    property <length> scope_x: 580px;
    property <length> scope_y: 80px;
    property <length> output_x: 580px;
    property <length> output_y: 320px;

    // Sine Oscillator Node
    sine_node := ModuleNode {
        x: sine_x;
        y: sine_y;
        node_title: "Sine Osc";
        outputs: [{label: "Out", jack_id: 0}];
        knobs: [{
            minimum: 20.0,
            maximum: 2000.0,
            value: 220.0,
            curve: KnobCurve.logarithmic,
            label: "Freq",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.sine_freq_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - sine_node.width);
            let max_y = max(0px, root.height - sine_node.height);
            sine_x = clamp_length(nx, 0px, max_x);
            sine_y = clamp_length(ny, 0px, max_y);
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Saw Oscillator Node
    saw_node := ModuleNode {
        x: saw_x;
        y: saw_y;
        node_title: "Saw Osc";
        outputs: [{label: "Out", jack_id: 1}];
        knobs: [{
            minimum: 20.0,
            maximum: 2000.0,
            value: 440.0,
            curve: KnobCurve.logarithmic,
            label: "Freq",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.saw_freq_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - saw_node.width);
            let max_y = max(0px, root.height - saw_node.height);
            saw_x = clamp_length(nx, 0px, max_x);
            saw_y = clamp_length(ny, 0px, max_y);
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Filter Node
    filter_node := ModuleNode {
        x: filter_x;
        y: filter_y;
        node_title: "Filter";
        inputs: [{label: "In", jack_id: 2}];
        outputs: [{label: "Out", jack_id: 3}];
        knobs: [
            {
                minimum: 100.0,
                maximum: 10000.0,
                value: 1000.0,
                curve: KnobCurve.logarithmic,
                label: "Cutoff",
                knob_index: 0
            },
            {
                minimum: 0.1,
                maximum: 10.0,
                value: 0.707,
                curve: KnobCurve.logarithmic,
                label: "Q",
                knob_index: 1
            }
        ];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => {
            if (idx == 0) {
                root.filter_cutoff_changed(val);
            } else if (idx == 1) {
                root.filter_q_changed(val);
            }
        }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - filter_node.width);
            let max_y = max(0px, root.height - filter_node.height);
            filter_x = clamp_length(nx, 0px, max_x);
            filter_y = clamp_length(ny, 0px, max_y);
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Oscilloscope Node
    scope_node := ModuleNode {
        x: scope_x;
        y: scope_y;
        width: 340px;
        node_title: "Scope";
        inputs: [{label: "In", jack_id: 5}];
        outputs: [{label: "Out", jack_id: 6}];
        knobs: [];
        extra_height: 120px;
        jack_clicked(id) => { handle_jack_click(id); }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - scope_node.width);
            let max_y = max(0px, root.height - scope_node.height);
            scope_x = clamp_length(nx, 0px, max_x);
            scope_y = clamp_length(ny, 0px, max_y);
        }

        Rectangle {
            x: 10px;
            y: 32px;
            width: parent.width - 20px;
            height: max(40px, parent.height - 74px);
            background: #1B2420;
            border-radius: 4px;
            clip: true;

            Image {
                x: 0px;
                y: 0px;
                width: 100%;
                height: 100%;
                source: root.scope_waveform;
            }
        }
    }

    // Output Node
    output_node := ModuleNode {
        x: output_x;
        y: output_y;
        node_title: "Output";
        inputs: [{label: "In", jack_id: 4}];
        knobs: [{
            minimum: 0.0,
            maximum: 1.0,
            value: 0.8,
            curve: KnobCurve.linear,
            label: "Level",
            knob_index: 0
        }];
        jack_clicked(id) => { handle_jack_click(id); }
        knob_changed(idx, val) => { root.volume_level_changed(val); }
        position_changed(nx, ny) => {
            let max_x = max(0px, root.width - output_node.width);
            let max_y = max(0px, root.height - output_node.height);
            output_x = clamp_length(nx, 0px, max_x);
            output_y = clamp_length(ny, 0px, max_y);
        }
        jack_drag_started(id, gx, gy) => { root.start_cable_drag(id, gx, gy); }
        jack_dragged(id, gx, gy) => { root.update_cable_drag(id, gx, gy); }
        jack_drag_finished(id, gx, gy) => { root.finish_cable_drag(id, gx, gy); }
    }

    // Draw cables on top of nodes using node-exposed jack positions
    if root.conn_sine_filter: Cable {
        x1: sine_x + sine_node.output_jack_x;
        y1: sine_y + sine_node.output_jack_y;
        x2: filter_x + filter_node.input_jack_x;
        y2: filter_y + filter_node.input_jack_y;
        cable_color: #FF6B6B;
    }

    if root.conn_sine_volume: Cable {
        x1: sine_x + sine_node.output_jack_x;
        y1: sine_y + sine_node.output_jack_y;
        x2: output_x + output_node.input_jack_x;
        y2: output_y + output_node.input_jack_y;
        cable_color: #FF6B6B;
    }

    if root.conn_sine_scope: Cable {
        x1: sine_x + sine_node.output_jack_x;
        y1: sine_y + sine_node.output_jack_y;
        x2: scope_x + scope_node.input_jack_x;
        y2: scope_y + scope_node.input_jack_y;
        cable_color: #FF6B6B;
    }

    if root.conn_saw_filter: Cable {
        x1: saw_x + saw_node.output_jack_x;
        y1: saw_y + saw_node.output_jack_y;
        x2: filter_x + filter_node.input_jack_x;
        y2: filter_y + filter_node.input_jack_y;
        cable_color: #4ECDC4;
    }

    if root.conn_saw_volume: Cable {
        x1: saw_x + saw_node.output_jack_x;
        y1: saw_y + saw_node.output_jack_y;
        x2: output_x + output_node.input_jack_x;
        y2: output_y + output_node.input_jack_y;
        cable_color: #4ECDC4;
    }

    if root.conn_saw_scope: Cable {
        x1: saw_x + saw_node.output_jack_x;
        y1: saw_y + saw_node.output_jack_y;
        x2: scope_x + scope_node.input_jack_x;
        y2: scope_y + scope_node.input_jack_y;
        cable_color: #4ECDC4;
    }

    if root.conn_filter_volume: Cable {
        x1: filter_x + filter_node.output_jack_x;
        y1: filter_y + filter_node.output_jack_y;
        x2: output_x + output_node.input_jack_x;
        y2: output_y + output_node.input_jack_y;
        cable_color: #FFE66D;
    }

    if root.conn_filter_scope: Cable {
        x1: filter_x + filter_node.output_jack_x;
        y1: filter_y + filter_node.output_jack_y;
        x2: scope_x + scope_node.input_jack_x;
        y2: scope_y + scope_node.input_jack_y;
        cable_color: #FFE66D;
    }

    if root.conn_scope_output: Cable {
        x1: scope_x + scope_node.output_jack_x;
        y1: scope_y + scope_node.output_jack_y;
        x2: output_x + output_node.input_jack_x;
        y2: output_y + output_node.input_jack_y;
        cable_color: #8AC6FF;
    }

    if root.active_jack_drag: Cable {
        x1: root.drag_start_x;
        y1: root.drag_start_y;
        x2: root.drag_cursor_x;
        y2: root.drag_cursor_y;
        cable_color: root.drag_preview_color();
    }

    // Helper function to check if an output has any connections
    function output_has_connection(jack_id: int) -> bool {
        if (jack_id == 0) { return root.conn_sine_filter || root.conn_sine_volume || root.conn_sine_scope; }
        if (jack_id == 1) { return root.conn_saw_filter || root.conn_saw_volume || root.conn_saw_scope; }
        if (jack_id == 3) { return root.conn_filter_volume || root.conn_filter_scope; }
        if (jack_id == 6) { return root.conn_scope_output; }
        return false;
    }

    // Helper function to disconnect all connections from an output
    function disconnect_output(jack_id: int) {
        if (jack_id == 0) {
            // Sine output
            if (root.conn_sine_filter) { root.disconnect(0, 2); }
            if (root.conn_sine_volume) { root.disconnect(0, 4); }
            if (root.conn_sine_scope) { root.disconnect(0, 5); }
        } else if (jack_id == 1) {
            // Saw output
            if (root.conn_saw_filter) { root.disconnect(1, 2); }
            if (root.conn_saw_volume) { root.disconnect(1, 4); }
            if (root.conn_saw_scope) { root.disconnect(1, 5); }
        } else if (jack_id == 3) {
            // Filter output
            if (root.conn_filter_volume) { root.disconnect(3, 4); }
            if (root.conn_filter_scope) { root.disconnect(3, 5); }
        } else if (jack_id == 6) {
            if (root.conn_scope_output) { root.disconnect(6, 4); }
        }
    }

    // Helper function
    function handle_jack_click(jack_id: int) {
        debug("handle_jack_click called with:", jack_id);

        let is_output = (jack_id == 0 || jack_id == 1 || jack_id == 3 || jack_id == 6);

        if (root.drag_from_jack == -1) {
            // First click - check if it's an output with existing connections
            if (is_output && root.output_has_connection(jack_id)) {
                debug("Disconnecting output:", jack_id);
                root.disconnect_output(jack_id);
            } else {
                // Start dragging from this jack
                debug("Starting drag from:", jack_id);
                root.drag_from_jack = jack_id;
            }
        } else {
            // Complete the connection
            let from = root.drag_from_jack;
            let to = jack_id;
            debug("Completing connection:", from, "->", to);

            // Validate connection (outputs are 0,1,3,5; inputs are 2,4)
            let from_is_output = (from == 0 || from == 1 || from == 3 || from == 6);
            let to_is_input = (to == 2 || to == 4 || to == 5);

            if (from_is_output && to_is_input) {
                // Send connection to backend
                debug("Valid connection, calling connect");
                root.connect(from, to);
            } else {
                debug("Invalid connection");
            }

            root.drag_from_jack = -1;
        }
    }
}
