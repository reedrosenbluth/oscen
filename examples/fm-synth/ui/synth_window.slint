global MathConstants {
    out property <float> natural_log_base: 2.718281828459045;
}

global KnobPalette {
    in-out property <brush> dial_bg: #A9A9A9;
    in-out property <brush> border: #BABABA;
    in-out property <brush> marker: #777777;
    in-out property <brush> title: #BABABA;
}

enum KnobCurve {
    linear,
    logarithmic,
}

component RotaryKnob inherits Rectangle {
    in property <float> minimum: 0.0;
    in property <float> maximum: 1.0;
    in property <float> step: 0.01;
    in-out property <float> value: minimum;
    in property <KnobCurve> curve: KnobCurve.linear;
    in property <string> label: "";
    in property <string> min_label: "";  // Optional custom label for minimum
    in property <string> max_label: "";  // Optional custom label for maximum
    in property <bool> show_bounds: true;  // Whether to show min/max labels
    in property <brush> bg_brush: KnobPalette.dial_bg;
    in property <brush> border_brush: KnobPalette.border;
    in property <brush> marker_brush: KnobPalette.marker;
    in property <brush> title_brush: KnobPalette.title;

    callback value_edited(float);
    callback drag_started();
    callback drag_ended();

    private property <length> dial_size: 50px;
    private property <float> range: max(0.0001, root.maximum - root.minimum);
    private property <float> normalized: root.value_to_normalized(root.value);
    private property <angle> angle: 225deg - 270deg * root.normalized;
    private property <float> marker_radius: (root.dial_size / 2 - 6px) / 1px;
    // Use custom labels if provided, otherwise format the value
    private property <string> minimum_text: root.min_label != "" ? root.min_label : root.format_value(root.minimum);
    private property <string> maximum_text: root.max_label != "" ? root.max_label : root.format_value(root.maximum);

    VerticalLayout {
        spacing: 12px;
        padding: 0px;

        HorizontalLayout {
            Rectangle {
                horizontal-stretch: 1;
                height: 0px;
                opacity: 0.0;
            }

            knob_body := VerticalLayout {
                spacing: 0px;

                HorizontalLayout {
                    spacing: 4px;

                    left_margin := Rectangle {
                        width: root.show_bounds ? minimum_value_label.preferred-width : 0px;
                        height: root.dial_size;

                        minimum_value_label := Text {
                            text: root.minimum_text;
                            font-size: 10px;
                            color: root.title_brush;
                            x: parent.width - self.width;
                            y: parent.height - self.height;
                            visible: root.show_bounds;
                        }
                    }

                    dial := Rectangle {
                        width: root.dial_size;
                        height: root.dial_size;
                        border-radius: root.dial_size / 2;
                        border-width: 2px;
                        border-color: root.border_brush;
                        background: root.bg_brush;

                        marker := Rectangle {
                            width: 5px;
                            height: 5px;
                            border-radius: 3px;
                            background: root.marker_brush;
                            x: parent.width / 2 + Math.cos(root.angle) * (root.marker_radius * 1px) - self.width / 2;
                            y: parent.height / 2 - Math.sin(root.angle) * (root.marker_radius * 1px) - self.height / 2;
                        }

                        TouchArea {
                            width: 100%;
                            height: 100%;
                            property <float> start-value: root.value;

                            pointer-event(event) => {
                                if (event.button != PointerEventButton.left) {
                                    return;
                                }
                                if (event.kind == PointerEventKind.down) {
                                    self.start-value = root.value;
                                    root.drag_started();
                                } else if (event.kind == PointerEventKind.up) {
                                    root.value_edited(root.value);
                                    root.drag_ended();
                                }
                            }

                            moved => {
                                let delta_px = (self.pressed-y - self.mouse-y) / 1px;
                                let delta = delta_px / 150.0;
                                root.update_value_by_normalized_delta(self.start-value, delta);
                            }
                        }
                    }

                    right_margin := Rectangle {
                        width: root.show_bounds ? maximum_value_label.preferred-width : 0px;
                        height: root.dial_size;

                        maximum_value_label := Text {
                            text: root.maximum_text;
                            font-size: 10px;
                            color: root.title_brush;
                            x: 0px;
                            y: parent.height - self.height;
                            visible: root.show_bounds;
                        }
                    }
                }
            }

            Rectangle {
                horizontal-stretch: 1;
                height: 0px;
                opacity: 0.0;
            }
        }

        Text {
            text: root.label;
            horizontal-alignment: center;
            font-size: 13px;
            font-weight: 500;
            color: root.title_brush;
        }
    }

    function update_value(new-value: float) {
        let clamped = max(root.minimum, min(root.maximum, new-value));
        let snapped = quantize(clamped);

        if (snapped == root.value) {
            return;
        }
        root.value = snapped;
        root.value_edited(root.value);
    }

    function update_value_by_normalized_delta(start_value: float, delta: float) {
        let start_normalized = root.value_to_normalized(start_value);
        let normalized = max(0.0, min(1.0, start_normalized + delta));
        let new_value = root.normalized_to_value(normalized);
        root.update_value(new_value);
    }

    function quantize(value: float) -> float {
        if (root.step <= 0) {
            return value;
        }
        let steps = Math.round((value - root.minimum) / root.step);
        return root.minimum + steps * root.step;
    }

    function value_to_normalized(value: float) -> float {
        let clamped = max(root.minimum, min(root.maximum, value));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return max(0.0, min(1.0, (Math.log(clamped, MathConstants.natural_log_base) - min_log) / (max_log - min_log)));
            }
        }
        return max(0.0, min(1.0, (clamped - root.minimum) / root.range));
    }

    function normalized_to_value(normalized: float) -> float {
        let clamped = max(0.0, min(1.0, normalized));
        if (root.curve == KnobCurve.logarithmic && root.minimum > 0 && root.maximum > 0) {
            let min_log = Math.log(root.minimum, MathConstants.natural_log_base);
            let max_log = Math.log(root.maximum, MathConstants.natural_log_base);
            if (min_log != max_log) {
                return Math.exp(min_log + (max_log - min_log) * clamped);
            }
        }
        return root.minimum + clamped * root.range;
    }

    function format_value(value: float) -> string {
        if (Math.abs(value) >= 1000.0) {
            let scaled = value / 1000.0;
            let rounded = root.format_number(scaled);
            return rounded + "k";
        }
        return root.format_number(value);
    }

    function format_number(value: float) -> string {
        let rounded = Math.round(value * 100.0) / 100.0;
        let as_int = Math.round(rounded);
        if (Math.abs(rounded - as_int) < 0.0001) {
            return @tr("{0}", as_int);
        }
        return @tr("{0}", rounded);
    }
}

// Operator row component - horizontal strip like Pivot's layout
component OperatorRow inherits Rectangle {
    in property <string> op_label: "3";
    in property <brush> accent_color: #666666;

    in-out property <float> ratio_value: 1.0;
    in-out property <float> level_value: 0.5;
    in-out property <float> feedback_value: 0.0;
    in-out property <float> route_value: 0.0;
    in-out property <float> attack_value: 0.01;
    in-out property <float> decay_value: 0.1;
    in-out property <float> sustain_value: 0.7;
    in-out property <float> release_value: 0.3;
    in property <bool> show_ratio: true;
    in property <bool> show_level: true;
    in property <bool> show_feedback: true;
    in property <bool> show_route: false;

    callback ratio_edited(float);
    callback level_edited(float);
    callback feedback_edited(float);
    callback route_edited(float);
    callback attack_edited(float);
    callback decay_edited(float);
    callback sustain_edited(float);
    callback release_edited(float);
    callback drag_started();
    callback drag_ended();

    // Format ratio to always show one decimal place (e.g., "3.0", "3.5")
    pure function format_ratio(value: float) -> string {
        // Round to one decimal place
        let rounded = Math.round(value * 10) / 10;
        let int_part = Math.floor(rounded);
        let dec_part = Math.round((rounded - int_part) * 10);
        return @tr("{0}.{1}", int_part, dec_part);
    }

    height: 90px;
    background: #333333;
    border-radius: 4px;

    HorizontalLayout {
        padding: 8px;
        spacing: 16px;

        // Sidebar with operator number (like Pivot's dice sidebar)
        Rectangle {
            width: 28px;
            background: root.accent_color;
            border-radius: 4px;

            VerticalLayout {
                alignment: center;

                Text {
                    text: root.op_label;
                    font-size: 22px;
                    font-weight: 700;
                    color: #FFFFFF;
                    horizontal-alignment: center;
                }
            }
        }

        // Route knob (only for carrier/OP1) - controls OP3 routing
        // Labels show destination: "2" = OP3→OP2, "1" = OP3→OP1
        if root.show_route: RotaryKnob {
            label: "route";
            minimum: 0.0;
            maximum: 1.0;
            step: 0.01;
            min_label: "2";
            max_label: "1";
            value: root.route_value;
            value_edited(value) => {
                root.route_value = value;
                root.route_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Ratio number display
        if root.show_ratio: VerticalLayout {
            alignment: center;
            width: 64px;

            Text {
                text: root.format_ratio(root.ratio_value);
                font-size: 36px;
                font-weight: 600;
                color: #EEEEEE;
                horizontal-alignment: center;
            }
        }

        // Ratio knob (for interaction) with "ratio" label underneath
        if root.show_ratio: RotaryKnob {
            label: "ratio";
            minimum: 0.5;
            maximum: 16.0;
            step: 0.5;
            value: root.ratio_value;
            value_edited(value) => {
                root.ratio_value = value;
                root.ratio_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Level knob
        if root.show_level: RotaryKnob {
            label: "level";
            minimum: 0.0;
            maximum: 2.0;
            step: 0.01;
            value: root.level_value;
            value_edited(value) => {
                root.level_value = value;
                root.level_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Feedback knob
        if root.show_feedback: RotaryKnob {
            label: "fbk";
            minimum: 0.0;
            maximum: 1.0;
            step: 0.01;
            value: root.feedback_value;
            value_edited(value) => {
                root.feedback_value = value;
                root.feedback_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Spacer pushes ADSR to the right
        Rectangle {
            horizontal-stretch: 1;
        }

        // Separator before ADSR
        Rectangle {
            width: 1px;
            background: #555555;
        }

        // ADSR knobs
        RotaryKnob {
            label: "A";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.attack_value;
            value_edited(value) => {
                root.attack_value = value;
                root.attack_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "D";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.decay_value;
            value_edited(value) => {
                root.decay_value = value;
                root.decay_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "S";
            minimum: 0.0;
            maximum: 1.0;
            step: 0.01;
            show_bounds: false;
            value: root.sustain_value;
            value_edited(value) => {
                root.sustain_value = value;
                root.sustain_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "R";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.release_value;
            value_edited(value) => {
                root.release_value = value;
                root.release_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }
    }
}

// Filter row component
component FilterRow inherits Rectangle {
    in-out property <float> cutoff_value: 2000.0;
    in-out property <float> resonance_value: 0.707;
    in-out property <float> attack_value: 0.01;
    in-out property <float> decay_value: 0.2;
    in-out property <float> sustain_value: 0.5;
    in-out property <float> release_value: 0.3;
    in-out property <float> env_amount_value: 0.0;

    callback cutoff_edited(float);
    callback resonance_edited(float);
    callback attack_edited(float);
    callback decay_edited(float);
    callback sustain_edited(float);
    callback release_edited(float);
    callback env_amount_edited(float);
    callback drag_started();
    callback drag_ended();

    height: 90px;
    background: #333333;
    border-radius: 4px;

    HorizontalLayout {
        padding: 8px;
        spacing: 16px;

        // Filter type indicator sidebar
        Rectangle {
            width: 28px;
            background: #785A4A;
            border-radius: 4px;

            VerticalLayout {
                alignment: center;

                Text {
                    text: "F";
                    font-size: 22px;
                    font-weight: 700;
                    color: #FFFFFF;
                    horizontal-alignment: center;
                }
            }
        }

        // Cutoff knob
        RotaryKnob {
            label: "cut";
            minimum: 20.0;
            maximum: 20000.0;
            step: 1.0;
            curve: KnobCurve.logarithmic;
            value: root.cutoff_value;
            value_edited(value) => {
                root.cutoff_value = value;
                root.cutoff_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Resonance knob
        RotaryKnob {
            label: "res";
            minimum: 0.1;
            maximum: 10.0;
            step: 0.01;
            value: root.resonance_value;
            value_edited(value) => {
                root.resonance_value = value;
                root.resonance_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Envelope amount knob (before spacer so ADSR aligns with other rows)
        RotaryKnob {
            label: "env";
            minimum: -10000.0;
            maximum: 10000.0;
            step: 10.0;
            show_bounds: false;
            value: root.env_amount_value;
            value_edited(value) => {
                root.env_amount_value = value;
                root.env_amount_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        // Spacer pushes ADSR to the right
        Rectangle {
            horizontal-stretch: 1;
        }

        // Separator before ADSR
        Rectangle {
            width: 1px;
            background: #555555;
        }

        // ADSR knobs for filter envelope
        RotaryKnob {
            label: "A";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.attack_value;
            value_edited(value) => {
                root.attack_value = value;
                root.attack_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "D";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.decay_value;
            value_edited(value) => {
                root.decay_value = value;
                root.decay_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "S";
            minimum: 0.0;
            maximum: 1.0;
            step: 0.01;
            show_bounds: false;
            value: root.sustain_value;
            value_edited(value) => {
                root.sustain_value = value;
                root.sustain_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }

        RotaryKnob {
            label: "R";
            minimum: 0.001;
            maximum: 2.0;
            step: 0.001;
            curve: KnobCurve.logarithmic;
            show_bounds: false;
            value: root.release_value;
            value_edited(value) => {
                root.release_value = value;
                root.release_edited(value);
            }
            drag_started => { root.drag_started(); }
            drag_ended => { root.drag_ended(); }
        }
    }
}

export component SynthWindow inherits Window {
    title: "Pivot";
    background: #1A1A1A;

    // OP3 parameters
    in-out property <float> op3_ratio: 3.0;
    in-out property <float> op3_level: 0.5;
    in-out property <float> op3_feedback: 0.0;
    in-out property <float> op3_attack: 0.01;
    in-out property <float> op3_decay: 0.1;
    in-out property <float> op3_sustain: 0.7;
    in-out property <float> op3_release: 0.3;

    // OP2 parameters
    in-out property <float> op2_ratio: 2.0;
    in-out property <float> op2_level: 0.5;
    in-out property <float> op2_feedback: 0.0;
    in-out property <float> op2_attack: 0.01;
    in-out property <float> op2_decay: 0.1;
    in-out property <float> op2_sustain: 0.7;
    in-out property <float> op2_release: 0.3;

    // OP1 envelope parameters (ratio and feedback not exposed - carrier only)
    in-out property <float> op1_attack: 0.01;
    in-out property <float> op1_decay: 0.2;
    in-out property <float> op1_sustain: 0.8;
    in-out property <float> op1_release: 0.5;

    // Route: blends OP3 between OP2 (0.0) and OP1 (1.0)
    in-out property <float> route: 0.0;

    // Filter parameters
    in-out property <float> filter_cutoff: 2000.0;
    in-out property <float> filter_resonance: 0.707;
    in-out property <float> filter_attack: 0.01;
    in-out property <float> filter_decay: 0.2;
    in-out property <float> filter_sustain: 0.5;
    in-out property <float> filter_release: 0.3;
    in-out property <float> filter_env_amount: 0.0;

    // Callbacks
    callback op3_ratio_edited(float);
    callback op3_level_edited(float);
    callback op3_feedback_edited(float);
    callback op3_attack_edited(float);
    callback op3_decay_edited(float);
    callback op3_sustain_edited(float);
    callback op3_release_edited(float);
    callback op2_ratio_edited(float);
    callback op2_level_edited(float);
    callback op2_feedback_edited(float);
    callback op2_attack_edited(float);
    callback op2_decay_edited(float);
    callback op2_sustain_edited(float);
    callback op2_release_edited(float);
    callback op1_attack_edited(float);
    callback op1_decay_edited(float);
    callback op1_sustain_edited(float);
    callback op1_release_edited(float);
    callback route_edited(float);
    callback filter_cutoff_edited(float);
    callback filter_resonance_edited(float);
    callback filter_attack_edited(float);
    callback filter_decay_edited(float);
    callback filter_sustain_edited(float);
    callback filter_release_edited(float);
    callback filter_env_amount_edited(float);
    callback knob_drag_started();
    callback knob_drag_ended();

    root_layout := VerticalLayout {
        padding: 12px;
        spacing: 8px;

        // OP3 Row (Top Modulator) - modulates OP2 or OP1
        OperatorRow {
            op_label: "3";
            accent_color: #5A4A78;
            ratio_value <=> root.op3_ratio;
            level_value <=> root.op3_level;
            feedback_value <=> root.op3_feedback;
            attack_value <=> root.op3_attack;
            decay_value <=> root.op3_decay;
            sustain_value <=> root.op3_sustain;
            release_value <=> root.op3_release;
            show_level: true;
            ratio_edited(value) => { root.op3_ratio_edited(value); }
            level_edited(value) => { root.op3_level_edited(value); }
            feedback_edited(value) => { root.op3_feedback_edited(value); }
            attack_edited(value) => { root.op3_attack_edited(value); }
            decay_edited(value) => { root.op3_decay_edited(value); }
            sustain_edited(value) => { root.op3_sustain_edited(value); }
            release_edited(value) => { root.op3_release_edited(value); }
            drag_started => { root.knob_drag_started(); }
            drag_ended => { root.knob_drag_ended(); }
        }

        // OP2 Row (Middle Modulator) - modulates OP1
        OperatorRow {
            op_label: "2";
            accent_color: #4A5A78;
            ratio_value <=> root.op2_ratio;
            level_value <=> root.op2_level;
            feedback_value <=> root.op2_feedback;
            attack_value <=> root.op2_attack;
            decay_value <=> root.op2_decay;
            sustain_value <=> root.op2_sustain;
            release_value <=> root.op2_release;
            show_level: true;
            ratio_edited(value) => { root.op2_ratio_edited(value); }
            level_edited(value) => { root.op2_level_edited(value); }
            feedback_edited(value) => { root.op2_feedback_edited(value); }
            attack_edited(value) => { root.op2_attack_edited(value); }
            decay_edited(value) => { root.op2_decay_edited(value); }
            sustain_edited(value) => { root.op2_sustain_edited(value); }
            release_edited(value) => { root.op2_release_edited(value); }
            drag_started => { root.knob_drag_started(); }
            drag_ended => { root.knob_drag_ended(); }
        }

        // OP1 Row (Carrier) - outputs audio at root frequency
        // Route control blends OP3 between OP2 (0) and OP1 (1)
        OperatorRow {
            op_label: "R";
            accent_color: #4A7860;
            route_value <=> root.route;
            attack_value <=> root.op1_attack;
            decay_value <=> root.op1_decay;
            sustain_value <=> root.op1_sustain;
            release_value <=> root.op1_release;
            show_ratio: false;
            show_level: false;
            show_feedback: false;
            show_route: true;
            route_edited(value) => { root.route_edited(value); }
            attack_edited(value) => { root.op1_attack_edited(value); }
            decay_edited(value) => { root.op1_decay_edited(value); }
            sustain_edited(value) => { root.op1_sustain_edited(value); }
            release_edited(value) => { root.op1_release_edited(value); }
            drag_started => { root.knob_drag_started(); }
            drag_ended => { root.knob_drag_ended(); }
        }

        // Filter Row
        FilterRow {
            cutoff_value <=> root.filter_cutoff;
            resonance_value <=> root.filter_resonance;
            attack_value <=> root.filter_attack;
            decay_value <=> root.filter_decay;
            sustain_value <=> root.filter_sustain;
            release_value <=> root.filter_release;
            env_amount_value <=> root.filter_env_amount;
            cutoff_edited(value) => { root.filter_cutoff_edited(value); }
            resonance_edited(value) => { root.filter_resonance_edited(value); }
            attack_edited(value) => { root.filter_attack_edited(value); }
            decay_edited(value) => { root.filter_decay_edited(value); }
            sustain_edited(value) => { root.filter_sustain_edited(value); }
            release_edited(value) => { root.filter_release_edited(value); }
            env_amount_edited(value) => { root.filter_env_amount_edited(value); }
            drag_started => { root.knob_drag_started(); }
            drag_ended => { root.knob_drag_ended(); }
        }
    }

    preferred-width: 750px;
    preferred-height: root_layout.preferred-height;
    min-width: 750px;
    min-height: root_layout.preferred-height;
}
